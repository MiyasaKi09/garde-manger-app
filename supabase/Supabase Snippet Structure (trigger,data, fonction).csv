object_type,object_name,ddl
FUNCTION,add_harvest_lot,"CREATE OR REPLACE FUNCTION public.add_harvest_lot(p_user_id uuid, p_product_id uuid, p_location_id uuid, p_qty numeric, p_unit text, p_best_before date, p_note text)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
declare
  v_id uuid;
begin
  insert into public.pantry_lots(user_id, product_id, location_id, qty, unit, best_before, note)
  values (p_user_id, p_product_id, p_location_id, p_qty, p_unit, p_best_before, p_note)
  returning id into v_id;

  return v_id;
end
$function$
"
FUNCTION,check_canonical_subcategory_match,"CREATE OR REPLACE FUNCTION public.check_canonical_subcategory_match()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  subcat_category BIGINT;
BEGIN
  IF NEW.subcategory_id IS NULL THEN
    RETURN NEW;
  END IF;

  SELECT category_id INTO subcat_category
  FROM reference_subcategories
  WHERE id = NEW.subcategory_id;

  IF subcat_category IS NULL THEN
    RAISE EXCEPTION 'Sous-catégorie inconnue: %', NEW.subcategory_id;
  END IF;

  IF NEW.category_id IS NULL OR NEW.category_id <> subcat_category THEN
    RAISE EXCEPTION 'La sous-catégorie (%) n''appartient pas à la catégorie (%).',
      NEW.subcategory_id, NEW.category_id;
  END IF;

  RETURN NEW;
END;
$function$
"
FUNCTION,cleanup_empty_lots_v2,"CREATE OR REPLACE FUNCTION public.cleanup_empty_lots_v2()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_deleted_count INTEGER;
BEGIN
    DELETE FROM inventory_lots 
    WHERE qty_remaining <= 0;
    
    GET DIAGNOSTICS v_deleted_count = ROW_COUNT;
    
    RETURN v_deleted_count;
END;
$function$
"
FUNCTION,consume_from_lot,"CREATE OR REPLACE FUNCTION public.consume_from_lot(p_lot_id uuid, p_qty numeric, p_reason text DEFAULT NULL::text)
 RETURNS numeric
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  remaining NUMERIC;
BEGIN
  UPDATE inventory_lots
  SET qty_remaining = GREATEST(0, COALESCE(qty_remaining, 0) - p_qty)
  WHERE id = p_lot_id
  RETURNING qty_remaining INTO remaining;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Lot % introuvable', p_lot_id;
  END IF;

  RETURN remaining;
END;
$function$
"
FUNCTION,consume_from_lot,"CREATE OR REPLACE FUNCTION public.consume_from_lot(p_lot_id uuid, p_qty numeric)
 RETURNS numeric
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  r NUMERIC;
BEGIN
  UPDATE inventory_lots
  SET qty_remaining = GREATEST(0, COALESCE(qty_remaining,0) - p_qty),
      updated_at = NOW()
  WHERE id = p_lot_id
  RETURNING qty_remaining INTO r;

  IF NOT FOUND THEN RAISE EXCEPTION 'Lot % introuvable', p_lot_id; END IF;
  RETURN r;
END; $function$
"
FUNCTION,consume_from_lot,"CREATE OR REPLACE FUNCTION public.consume_from_lot(p_lot_id uuid, p_qty numeric)
 RETURNS numeric
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  r NUMERIC;
BEGIN
  UPDATE inventory_lots
  SET qty_remaining = GREATEST(0, COALESCE(qty_remaining,0) - p_qty),
      updated_at = NOW()
  WHERE id = p_lot_id
  RETURNING qty_remaining INTO r;

  IF NOT FOUND THEN RAISE EXCEPTION 'Lot % introuvable', p_lot_id; END IF;
  RETURN r;
END; $function$
"
FUNCTION,consume_from_lot,"CREATE OR REPLACE FUNCTION public.consume_from_lot(p_lot_id uuid, p_qty numeric, p_reason text DEFAULT NULL::text)
 RETURNS numeric
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  remaining NUMERIC;
BEGIN
  UPDATE inventory_lots
  SET qty_remaining = GREATEST(0, COALESCE(qty_remaining, 0) - p_qty)
  WHERE id = p_lot_id
  RETURNING qty_remaining INTO remaining;

  IF NOT FOUND THEN
    RAISE EXCEPTION 'Lot % introuvable', p_lot_id;
  END IF;

  RETURN remaining;
END;
$function$
"
FUNCTION,convert_qty,"CREATE OR REPLACE FUNCTION public.convert_qty(p_from_unit text, p_to_unit text, p_qty numeric)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN convert_qty_v2(p_from_unit, p_to_unit, p_qty);
END;
$function$
"
FUNCTION,convert_qty_v2,"CREATE OR REPLACE FUNCTION public.convert_qty_v2(p_from_unit text, p_to_unit text, p_qty numeric)
 RETURNS numeric
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Si les unités sont identiques, retour direct
    IF p_from_unit = p_to_unit THEN
        RETURN p_qty;
    END IF;
    
    -- Conversions de base poids
    IF p_from_unit = 'kg' AND p_to_unit = 'g' THEN
        RETURN p_qty * 1000;
    ELSIF p_from_unit = 'g' AND p_to_unit = 'kg' THEN
        RETURN p_qty / 1000;
        
    -- Conversions de base volume
    ELSIF p_from_unit = 'l' AND p_to_unit = 'ml' THEN
        RETURN p_qty * 1000;
    ELSIF p_from_unit = 'ml' AND p_to_unit = 'l' THEN
        RETURN p_qty / 1000;
        
    -- Conversions courantes
    ELSIF p_from_unit = 'cl' AND p_to_unit = 'ml' THEN
        RETURN p_qty * 10;
    ELSIF p_from_unit = 'ml' AND p_to_unit = 'cl' THEN
        RETURN p_qty / 10;
    END IF;
    
    -- Pas de conversion possible ou unités non supportées
    RETURN p_qty; -- Retourner la quantité originale
END;
$function$
"
FUNCTION,duplicate_recipe,"CREATE OR REPLACE FUNCTION public.duplicate_recipe(source_recipe_id uuid, new_title text DEFAULT NULL::text)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
    new_recipe_id uuid;
BEGIN
    -- Copier la recette principale
    INSERT INTO recipes (
        title, steps, time_min, difficulty, tags, category, 
        is_veg, servings, prep_min, cook_min, description, 
        image_url, is_divisible, author
    )
    SELECT 
        COALESCE(new_title, title || ' (copie)'),
        steps, time_min, difficulty, tags, category,
        is_veg, servings, prep_min, cook_min, description,
        image_url, is_divisible, author
    FROM recipes
    WHERE id = source_recipe_id
    RETURNING id INTO new_recipe_id;
    
    -- Copier les ingrédients
    INSERT INTO recipe_ingredients (
        recipe_id, product_id, qty, unit, note, position, is_optional, preparation
    )
    SELECT 
        new_recipe_id, product_id, qty, unit, note, position, is_optional, preparation
    FROM recipe_ingredients
    WHERE recipe_id = source_recipe_id;
    
    -- Copier les ustensiles
    INSERT INTO recipe_utensils (
        recipe_id, utensil_name, quantity, is_optional, notes
    )
    SELECT 
        new_recipe_id, utensil_name, quantity, is_optional, notes
    FROM recipe_utensils
    WHERE recipe_id = source_recipe_id;
    
    -- Copier les étapes
    INSERT INTO recipe_steps (
        recipe_id, step_no, instruction, duration_min, temperature, temperature_unit
    )
    SELECT 
        new_recipe_id, step_no, instruction, duration_min, temperature, temperature_unit
    FROM recipe_steps
    WHERE recipe_id = source_recipe_id;
    
    RETURN new_recipe_id;
END;
$function$
"
FUNCTION,find_compatible_products,"CREATE OR REPLACE FUNCTION public.find_compatible_products(ingredient_id uuid, search_term text DEFAULT NULL::text)
 RETURNS TABLE(product_id bigint, product_name text, product_type text, category_name text, match_score integer)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    WITH ingredient_info AS (
        SELECT * FROM recipe_ingredients_detailed WHERE id = ingredient_id
    )
    -- Chercher les produits compatibles
    SELECT DISTINCT
        cf.id as product_id,
        cf.canonical_name as product_name,
        'canonical'::text as product_type,
        rc.name as category_name,
        CASE 
            -- Score plus élevé si le nom correspond
            WHEN search_term IS NOT NULL AND 
                 LOWER(cf.canonical_name) LIKE '%' || LOWER(search_term) || '%' 
            THEN 100
            -- Score moyen si même catégorie
            WHEN cf.category_id = (SELECT category_id FROM ingredient_info) 
            THEN 50
            ELSE 10
        END as match_score
    FROM canonical_foods cf
    LEFT JOIN reference_categories rc ON cf.category_id = rc.id
    WHERE search_term IS NULL 
       OR LOWER(cf.canonical_name) LIKE '%' || LOWER(search_term) || '%'
    
    UNION ALL
    
    SELECT 
        gp.id as product_id,
        gp.name as product_name,
        'generic'::text as product_type,
        rc.name as category_name,
        CASE 
            WHEN search_term IS NOT NULL AND 
                 LOWER(gp.name) LIKE '%' || LOWER(search_term) || '%' 
            THEN 100
            WHEN gp.category_id = (SELECT category_id FROM ingredient_info) 
            THEN 50
            ELSE 10
        END as match_score
    FROM generic_products gp
    LEFT JOIN reference_categories rc ON gp.category_id = rc.id
    WHERE search_term IS NULL 
       OR LOWER(gp.name) LIKE '%' || LOWER(search_term) || '%'
    
    ORDER BY match_score DESC, product_name
    LIMIT 20;
END;
$function$
"
FUNCTION,get_expiry_alerts,"CREATE OR REPLACE FUNCTION public.get_expiry_alerts(p_days_ahead integer DEFAULT 7)
 RETURNS TABLE(lot_id bigint, product_name text, quantity numeric, unit text, expiration_date date, days_until_expiry integer, alert_level text, storage_method text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        il.id as lot_id,
        vid.display_name as product_name,
        il.qty_remaining as quantity,
        il.unit,
        il.expiration_date,
        (il.expiration_date - CURRENT_DATE)::INTEGER as days_until_expiry,
        CASE 
            WHEN il.expiration_date < CURRENT_DATE THEN 'expired'
            WHEN il.expiration_date = CURRENT_DATE THEN 'expires_today'
            WHEN il.expiration_date <= CURRENT_DATE + INTERVAL '3 days' THEN 'expires_soon'
            ELSE 'warning'
        END as alert_level,
        COALESCE(il.storage_method, 'unknown') as storage_method
    FROM inventory_lots il
    JOIN v_inventory_display vid ON vid.id = il.id
    WHERE il.qty_remaining > 0 
      AND il.expiration_date IS NOT NULL
      AND il.expiration_date <= CURRENT_DATE + (p_days_ahead || ' days')::INTERVAL
    ORDER BY il.expiration_date ASC, product_name ASC;
END;
$function$
"
FUNCTION,get_pantry_summary,"CREATE OR REPLACE FUNCTION public.get_pantry_summary()
 RETURNS TABLE(product_name text, product_type text, total_quantity numeric, unit text, lot_count bigint, next_expiry date, category_name text, category_icon text)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    SELECT 
        vid.display_name as product_name,
        vid.product_type,
        SUM(vid.qty_remaining) as total_quantity,
        vid.unit,
        COUNT(*) as lot_count,
        MIN(vid.effective_expiration) as next_expiry,
        COALESCE(vid.category_name, 'Non catégorisé') as category_name,
        COALESCE(vid.category_icon, '📦') as category_icon
    FROM v_inventory_display vid
    WHERE vid.qty_remaining > 0
    GROUP BY 
        vid.display_name,
        vid.product_type,
        vid.unit,
        vid.category_name,
        vid.category_icon
    ORDER BY next_expiry ASC NULLS LAST, product_name ASC;
END;
$function$
"
FUNCTION,gin_extract_query_trgm,"CREATE OR REPLACE FUNCTION public.gin_extract_query_trgm(text, internal, smallint, internal, internal, internal, internal)
 RETURNS internal
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gin_extract_query_trgm$function$
"
FUNCTION,gin_extract_value_trgm,"CREATE OR REPLACE FUNCTION public.gin_extract_value_trgm(text, internal)
 RETURNS internal
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gin_extract_value_trgm$function$
"
FUNCTION,gin_trgm_consistent,"CREATE OR REPLACE FUNCTION public.gin_trgm_consistent(internal, smallint, text, integer, internal, internal, internal, internal)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gin_trgm_consistent$function$
"
FUNCTION,gin_trgm_triconsistent,"CREATE OR REPLACE FUNCTION public.gin_trgm_triconsistent(internal, smallint, text, integer, internal, internal, internal)
 RETURNS ""char""
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gin_trgm_triconsistent$function$
"
FUNCTION,gtrgm_compress,"CREATE OR REPLACE FUNCTION public.gtrgm_compress(internal)
 RETURNS internal
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_compress$function$
"
FUNCTION,gtrgm_consistent,"CREATE OR REPLACE FUNCTION public.gtrgm_consistent(internal, text, smallint, oid, internal)
 RETURNS boolean
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_consistent$function$
"
FUNCTION,gtrgm_decompress,"CREATE OR REPLACE FUNCTION public.gtrgm_decompress(internal)
 RETURNS internal
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_decompress$function$
"
FUNCTION,gtrgm_distance,"CREATE OR REPLACE FUNCTION public.gtrgm_distance(internal, text, smallint, oid, internal)
 RETURNS double precision
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_distance$function$
"
FUNCTION,gtrgm_in,"CREATE OR REPLACE FUNCTION public.gtrgm_in(cstring)
 RETURNS gtrgm
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_in$function$
"
FUNCTION,gtrgm_options,"CREATE OR REPLACE FUNCTION public.gtrgm_options(internal)
 RETURNS void
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE
AS '$libdir/pg_trgm', $function$gtrgm_options$function$
"
FUNCTION,gtrgm_out,"CREATE OR REPLACE FUNCTION public.gtrgm_out(gtrgm)
 RETURNS cstring
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_out$function$
"
FUNCTION,gtrgm_penalty,"CREATE OR REPLACE FUNCTION public.gtrgm_penalty(internal, internal, internal)
 RETURNS internal
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_penalty$function$
"
FUNCTION,gtrgm_picksplit,"CREATE OR REPLACE FUNCTION public.gtrgm_picksplit(internal, internal)
 RETURNS internal
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_picksplit$function$
"
FUNCTION,gtrgm_same,"CREATE OR REPLACE FUNCTION public.gtrgm_same(gtrgm, gtrgm, internal)
 RETURNS internal
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_same$function$
"
FUNCTION,gtrgm_union,"CREATE OR REPLACE FUNCTION public.gtrgm_union(internal, internal)
 RETURNS gtrgm
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$gtrgm_union$function$
"
FUNCTION,is_allowed,"CREATE OR REPLACE FUNCTION public.is_allowed()
 RETURNS boolean
 LANGUAGE sql
 STABLE SECURITY DEFINER
 SET search_path TO 'public'
AS $function$
  select (auth.jwt() ->> 'email') in ('julenglet@gmail.com','zoefhebert@gmail.com');
$function$
"
FUNCTION,link_ingredient_to_product,"CREATE OR REPLACE FUNCTION public.link_ingredient_to_product(p_ingredient_id uuid, p_product_id bigint, p_product_type text, p_specificity text DEFAULT 'any'::text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Réinitialiser tous les liens produits
    UPDATE recipe_ingredients 
    SET 
        canonical_food_id = NULL,
        generic_product_id = NULL,
        cultivar_id = NULL,
        derived_product_id = NULL,
        product_specificity = p_specificity
    WHERE id = p_ingredient_id;
    
    -- Définir le bon lien selon le type
    CASE p_product_type
        WHEN 'canonical' THEN
            UPDATE recipe_ingredients 
            SET canonical_food_id = p_product_id
            WHERE id = p_ingredient_id;
        WHEN 'generic' THEN
            UPDATE recipe_ingredients 
            SET generic_product_id = p_product_id
            WHERE id = p_ingredient_id;
        WHEN 'cultivar' THEN
            UPDATE recipe_ingredients 
            SET cultivar_id = p_product_id
            WHERE id = p_ingredient_id;
        WHEN 'derived' THEN
            UPDATE recipe_ingredients 
            SET derived_product_id = p_product_id
            WHERE id = p_ingredient_id;
    END CASE;
END;
$function$
"
FUNCTION,norm_text,"CREATE OR REPLACE FUNCTION public.norm_text(s text)
 RETURNS text
 LANGUAGE sql
 IMMUTABLE
AS $function$
  select lower(trim(regexp_replace(coalesce(s,''), '\s+', ' ', 'g')))
$function$
"
FUNCTION,open_one_unit,"CREATE OR REPLACE FUNCTION public.open_one_unit(p_lot_id text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ -- Retourne UUID ou BIGINT en string
DECLARE
  lot inventory_lots%ROWTYPE;
  prod products%ROWTYPE;
  arch archetypes%ROWTYPE;
  child_id TEXT;
  open_days INT;
  open_unit TEXT;
  v_id_type TEXT;
BEGIN
  -- Déterminer le type d'ID utilisé
  SELECT data_type INTO v_id_type
  FROM information_schema.columns 
  WHERE table_name = 'inventory_lots' 
  AND column_name = 'id';
  
  -- Récupérer le lot selon le type
  IF v_id_type = 'uuid' THEN
    SELECT * INTO lot FROM inventory_lots WHERE id = p_lot_id::UUID FOR UPDATE;
  ELSE
    SELECT * INTO lot FROM inventory_lots WHERE id = p_lot_id::BIGINT FOR UPDATE;
  END IF;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Lot % introuvable', p_lot_id;
  END IF;

  IF COALESCE(lot.package_units_remaining, 0) <= 0 THEN
    RAISE EXCEPTION 'Aucune unité fermée pour lot %', p_lot_id;
  END IF;

  IF lot.product_id IS NOT NULL THEN
    SELECT * INTO prod FROM products WHERE id = lot.product_id;
  END IF;
  
  IF lot.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = lot.archetype_id;
  ELSIF prod.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = prod.archetype_id;
  END IF;

  open_days := COALESCE(prod.shelf_life_after_opening_days, arch.open_shelf_life_days);
  open_unit := COALESCE(prod.shelf_life_after_opening_unit, arch.open_shelf_life_unit, 'days');

  -- Créer le nouveau lot
  INSERT INTO inventory_lots (
    canonical_food_id, cultivar_id, derived_product_id, generic_product_id,
    product_id, archetype_id, location_id,
    initial_qty, qty_remaining, unit,
    package_units_total, package_units_remaining,
    qty_per_unit, qty_per_unit_unit,
    is_opened, opened_on,
    expiration_date, expiration_after_opening,
    acquired_on, parent_lot_id, notes, source
  ) VALUES (
    lot.canonical_food_id, lot.cultivar_id, lot.derived_product_id, lot.generic_product_id,
    lot.product_id, lot.archetype_id, lot.location_id,
    lot.qty_per_unit, lot.qty_per_unit, COALESCE(lot.qty_per_unit_unit, lot.unit),
    1, 0,
    lot.qty_per_unit, lot.qty_per_unit_unit,
    TRUE, CURRENT_DATE,
    lot.expiration_date,
    CASE 
      WHEN open_days IS NOT NULL THEN
        CASE open_unit
          WHEN 'hours' THEN (CURRENT_DATE + (open_days || ' hours')::INTERVAL)::DATE
          ELSE (CURRENT_DATE + (open_days || ' days')::INTERVAL)::DATE
        END
      ELSE NULL 
    END,
    CURRENT_DATE, lot.id, 'Unité ouverte depuis lot ' || lot.id::TEXT, 'split'
  ) RETURNING id::TEXT INTO child_id;

  -- Mettre à jour le lot parent
  IF v_id_type = 'uuid' THEN
    UPDATE inventory_lots
    SET package_units_remaining = COALESCE(package_units_remaining, 0) - 1,
        qty_remaining = COALESCE(qty_remaining, 0) - COALESCE(qty_per_unit, 0)
    WHERE id = p_lot_id::UUID;
  ELSE
    UPDATE inventory_lots
    SET package_units_remaining = COALESCE(package_units_remaining, 0) - 1,
        qty_remaining = COALESCE(qty_remaining, 0) - COALESCE(qty_per_unit, 0)
    WHERE id = p_lot_id::BIGINT;
  END IF;

  RETURN child_id;
END;
$function$
"
FUNCTION,open_one_unit,"CREATE OR REPLACE FUNCTION public.open_one_unit(p_lot_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  lot         inventory_lots%ROWTYPE;
  prod        products%ROWTYPE;
  arch        archetypes%ROWTYPE;
  child_id    UUID;
  open_days   INT;
  open_unit   TEXT;
BEGIN
  SELECT * INTO lot FROM inventory_lots WHERE id = p_lot_id FOR UPDATE;
  IF NOT FOUND THEN RAISE EXCEPTION 'Lot % introuvable', p_lot_id; END IF;

  IF lot.package_units_remaining IS NULL OR lot.package_units_remaining <= 0 THEN
    RAISE EXCEPTION 'Aucune unité fermée à ouvrir pour le lot %', p_lot_id;
  END IF;

  IF lot.product_id IS NOT NULL THEN SELECT * INTO prod FROM products WHERE id = lot.product_id; END IF;
  IF lot.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = lot.archetype_id;
  ELSIF prod.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = prod.archetype_id;
  END IF;

  open_days := COALESCE(prod.shelf_life_after_opening_days, arch.open_shelf_life_days);
  open_unit := COALESCE(prod.shelf_life_after_opening_unit, arch.open_shelf_life_unit, 'days');

  child_id := gen_random_uuid();
  INSERT INTO inventory_lots (
    id, product_id, archetype_id,
    initial_qty, qty_remaining, unit,
    package_units_total, package_units_remaining, qty_per_unit, qty_per_unit_unit,
    is_opened, opened_on, expiration_date, expiration_after_opening,
    acquired_on, parent_lot_id, notes
  )
  VALUES (
    child_id,
    lot.product_id, lot.archetype_id,
    lot.qty_per_unit, lot.qty_per_unit, lot.qty_per_unit_unit,
    1, 0, lot.qty_per_unit, lot.qty_per_unit_unit,
    TRUE, CURRENT_DATE, lot.expiration_date,
    CASE
      WHEN open_days IS NOT NULL THEN
        CASE open_unit
          WHEN 'hours' THEN (CURRENT_DATE + (open_days || ' hours')::INTERVAL)::DATE
          ELSE            (CURRENT_DATE + (open_days || ' days')::INTERVAL)::DATE
        END
      ELSE NULL
    END,
    CURRENT_DATE, lot.id, 'Ouverture auto 1 unité'
  );

  UPDATE inventory_lots
  SET package_units_remaining = package_units_remaining - 1,
      qty_remaining = COALESCE(qty_remaining, 0) - COALESCE(lot.qty_per_unit, 0),
      updated_at = NOW()
  WHERE id = lot.id;

  RETURN child_id;
END; $function$
"
FUNCTION,open_one_unit,"CREATE OR REPLACE FUNCTION public.open_one_unit(p_lot_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
  lot         inventory_lots%ROWTYPE;
  prod        products%ROWTYPE;
  arch        archetypes%ROWTYPE;
  child_id    UUID;
  open_days   INT;
  open_unit   TEXT;
BEGIN
  SELECT * INTO lot FROM inventory_lots WHERE id = p_lot_id FOR UPDATE;
  IF NOT FOUND THEN RAISE EXCEPTION 'Lot % introuvable', p_lot_id; END IF;

  IF lot.package_units_remaining IS NULL OR lot.package_units_remaining <= 0 THEN
    RAISE EXCEPTION 'Aucune unité fermée à ouvrir pour le lot %', p_lot_id;
  END IF;

  IF lot.product_id IS NOT NULL THEN SELECT * INTO prod FROM products WHERE id = lot.product_id; END IF;
  IF lot.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = lot.archetype_id;
  ELSIF prod.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = prod.archetype_id;
  END IF;

  open_days := COALESCE(prod.shelf_life_after_opening_days, arch.open_shelf_life_days);
  open_unit := COALESCE(prod.shelf_life_after_opening_unit, arch.open_shelf_life_unit, 'days');

  child_id := gen_random_uuid();
  INSERT INTO inventory_lots (
    id, product_id, archetype_id,
    initial_qty, qty_remaining, unit,
    package_units_total, package_units_remaining, qty_per_unit, qty_per_unit_unit,
    is_opened, opened_on, expiration_date, expiration_after_opening,
    acquired_on, parent_lot_id, notes
  )
  VALUES (
    child_id,
    lot.product_id, lot.archetype_id,
    lot.qty_per_unit, lot.qty_per_unit, lot.qty_per_unit_unit,
    1, 0, lot.qty_per_unit, lot.qty_per_unit_unit,
    TRUE, CURRENT_DATE, lot.expiration_date,
    CASE
      WHEN open_days IS NOT NULL THEN
        CASE open_unit
          WHEN 'hours' THEN (CURRENT_DATE + (open_days || ' hours')::INTERVAL)::DATE
          ELSE            (CURRENT_DATE + (open_days || ' days')::INTERVAL)::DATE
        END
      ELSE NULL
    END,
    CURRENT_DATE, lot.id, 'Ouverture auto 1 unité'
  );

  UPDATE inventory_lots
  SET package_units_remaining = package_units_remaining - 1,
      qty_remaining = COALESCE(qty_remaining, 0) - COALESCE(lot.qty_per_unit, 0),
      updated_at = NOW()
  WHERE id = lot.id;

  RETURN child_id;
END; $function$
"
FUNCTION,open_one_unit,"CREATE OR REPLACE FUNCTION public.open_one_unit(p_lot_id text)
 RETURNS text
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$ -- Retourne UUID ou BIGINT en string
DECLARE
  lot inventory_lots%ROWTYPE;
  prod products%ROWTYPE;
  arch archetypes%ROWTYPE;
  child_id TEXT;
  open_days INT;
  open_unit TEXT;
  v_id_type TEXT;
BEGIN
  -- Déterminer le type d'ID utilisé
  SELECT data_type INTO v_id_type
  FROM information_schema.columns 
  WHERE table_name = 'inventory_lots' 
  AND column_name = 'id';
  
  -- Récupérer le lot selon le type
  IF v_id_type = 'uuid' THEN
    SELECT * INTO lot FROM inventory_lots WHERE id = p_lot_id::UUID FOR UPDATE;
  ELSE
    SELECT * INTO lot FROM inventory_lots WHERE id = p_lot_id::BIGINT FOR UPDATE;
  END IF;
  
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Lot % introuvable', p_lot_id;
  END IF;

  IF COALESCE(lot.package_units_remaining, 0) <= 0 THEN
    RAISE EXCEPTION 'Aucune unité fermée pour lot %', p_lot_id;
  END IF;

  IF lot.product_id IS NOT NULL THEN
    SELECT * INTO prod FROM products WHERE id = lot.product_id;
  END IF;
  
  IF lot.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = lot.archetype_id;
  ELSIF prod.archetype_id IS NOT NULL THEN
    SELECT * INTO arch FROM archetypes WHERE id = prod.archetype_id;
  END IF;

  open_days := COALESCE(prod.shelf_life_after_opening_days, arch.open_shelf_life_days);
  open_unit := COALESCE(prod.shelf_life_after_opening_unit, arch.open_shelf_life_unit, 'days');

  -- Créer le nouveau lot
  INSERT INTO inventory_lots (
    canonical_food_id, cultivar_id, derived_product_id, generic_product_id,
    product_id, archetype_id, location_id,
    initial_qty, qty_remaining, unit,
    package_units_total, package_units_remaining,
    qty_per_unit, qty_per_unit_unit,
    is_opened, opened_on,
    expiration_date, expiration_after_opening,
    acquired_on, parent_lot_id, notes, source
  ) VALUES (
    lot.canonical_food_id, lot.cultivar_id, lot.derived_product_id, lot.generic_product_id,
    lot.product_id, lot.archetype_id, lot.location_id,
    lot.qty_per_unit, lot.qty_per_unit, COALESCE(lot.qty_per_unit_unit, lot.unit),
    1, 0,
    lot.qty_per_unit, lot.qty_per_unit_unit,
    TRUE, CURRENT_DATE,
    lot.expiration_date,
    CASE 
      WHEN open_days IS NOT NULL THEN
        CASE open_unit
          WHEN 'hours' THEN (CURRENT_DATE + (open_days || ' hours')::INTERVAL)::DATE
          ELSE (CURRENT_DATE + (open_days || ' days')::INTERVAL)::DATE
        END
      ELSE NULL 
    END,
    CURRENT_DATE, lot.id, 'Unité ouverte depuis lot ' || lot.id::TEXT, 'split'
  ) RETURNING id::TEXT INTO child_id;

  -- Mettre à jour le lot parent
  IF v_id_type = 'uuid' THEN
    UPDATE inventory_lots
    SET package_units_remaining = COALESCE(package_units_remaining, 0) - 1,
        qty_remaining = COALESCE(qty_remaining, 0) - COALESCE(qty_per_unit, 0)
    WHERE id = p_lot_id::UUID;
  ELSE
    UPDATE inventory_lots
    SET package_units_remaining = COALESCE(package_units_remaining, 0) - 1,
        qty_remaining = COALESCE(qty_remaining, 0) - COALESCE(qty_per_unit, 0)
    WHERE id = p_lot_id::BIGINT;
  END IF;

  RETURN child_id;
END;
$function$
"
FUNCTION,search_products,"CREATE OR REPLACE FUNCTION public.search_products(p_query text, p_limit integer DEFAULT 20)
 RETURNS TABLE(product_id text, product_type text, product_name text, display_name text, category_name text, category_icon text, primary_unit text, relevance_score numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY SELECT * FROM search_products_v2(p_query, p_limit);
END;
$function$
"
FUNCTION,search_products_v2,"CREATE OR REPLACE FUNCTION public.search_products_v2(p_query text, p_limit integer DEFAULT 20)
 RETURNS TABLE(product_id text, product_type text, product_name text, display_name text, category_name text, category_icon text, primary_unit text, relevance_score numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN
    RETURN QUERY
    -- Recherche dans les aliments canoniques
    SELECT 
        cf.id::TEXT as product_id,
        'canonical'::TEXT as product_type,
        cf.canonical_name as product_name,
        cf.canonical_name as display_name,
        COALESCE(rc.name, '') as category_name,
        COALESCE(rc.icon, '📦') as category_icon,
        COALESCE(cf.primary_unit, 'g') as primary_unit,
        CASE 
            WHEN cf.canonical_name ILIKE p_query THEN 1.0
            WHEN cf.canonical_name ILIKE p_query || '%' THEN 2.0
            WHEN cf.canonical_name ILIKE '%' || p_query || '%' THEN 3.0
            ELSE 4.0
        END as relevance_score
    FROM canonical_foods cf
    LEFT JOIN reference_categories rc ON cf.category_id = rc.id
    WHERE cf.canonical_name ILIKE '%' || p_query || '%'
       OR EXISTS (SELECT 1 FROM unnest(cf.keywords) kw WHERE kw ILIKE '%' || p_query || '%')
    
    UNION ALL
    
    -- Recherche dans les cultivars
    SELECT 
        cv.id::TEXT as product_id,
        'cultivar'::TEXT as product_type,
        cv.cultivar_name as product_name,
        cv.cultivar_name || ' (' || cf.canonical_name || ')' as display_name,
        COALESCE(rc.name, '') as category_name,
        COALESCE(rc.icon, '🌱') as category_icon,
        COALESCE(cf.primary_unit, 'g') as primary_unit,
        CASE 
            WHEN cv.cultivar_name ILIKE p_query THEN 1.0
            WHEN cv.cultivar_name ILIKE p_query || '%' THEN 2.0
            WHEN cv.cultivar_name ILIKE '%' || p_query || '%' THEN 3.0
            ELSE 4.0
        END as relevance_score
    FROM cultivars cv
    JOIN canonical_foods cf ON cv.canonical_food_id = cf.id
    LEFT JOIN reference_categories rc ON cf.category_id = rc.id
    WHERE cv.cultivar_name ILIKE '%' || p_query || '%'
       OR EXISTS (SELECT 1 FROM unnest(cv.synonyms) syn WHERE syn ILIKE '%' || p_query || '%')
    
    UNION ALL
    
    -- Recherche dans les produits génériques
    SELECT 
        gp.id::TEXT as product_id,
        'generic'::TEXT as product_type,
        gp.name as product_name,
        gp.name as display_name,
        COALESCE(rc.name, '') as category_name,
        COALESCE(rc.icon, '📦') as category_icon,
        COALESCE(gp.primary_unit, 'g') as primary_unit,
        CASE 
            WHEN gp.name ILIKE p_query THEN 1.0
            WHEN gp.name ILIKE p_query || '%' THEN 2.0
            WHEN gp.name ILIKE '%' || p_query || '%' THEN 3.0
            ELSE 4.0
        END as relevance_score
    FROM generic_products gp
    LEFT JOIN reference_categories rc ON gp.category_id = rc.id
    WHERE gp.name ILIKE '%' || p_query || '%'
       OR EXISTS (SELECT 1 FROM unnest(gp.keywords) kw WHERE kw ILIKE '%' || p_query || '%')
    
    ORDER BY relevance_score ASC, product_name ASC
    LIMIT p_limit;
END;
$function$
"
FUNCTION,set_limit,"CREATE OR REPLACE FUNCTION public.set_limit(real)
 RETURNS real
 LANGUAGE c
 STRICT
AS '$libdir/pg_trgm', $function$set_limit$function$
"
FUNCTION,set_open_expiration,"CREATE OR REPLACE FUNCTION public.set_open_expiration()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
  prod products%ROWTYPE;
  arch archetypes%ROWTYPE;
  d    INT;
  u    TEXT;
BEGIN
  IF NEW.is_opened = TRUE AND (OLD.is_opened IS DISTINCT FROM TRUE) THEN
    IF NEW.opened_on IS NULL THEN
      NEW.opened_on := CURRENT_DATE;
    END IF;

    -- Charger le produit/archetype pour connaître les règles ""après ouverture""
    IF NEW.product_id IS NOT NULL THEN
      SELECT * INTO prod FROM products WHERE id = NEW.product_id;
    END IF;

    IF NEW.archetype_id IS NOT NULL THEN
      SELECT * INTO arch FROM archetypes WHERE id = NEW.archetype_id;
    ELSIF NEW.product_id IS NOT NULL AND prod.archetype_id IS NOT NULL THEN
      SELECT * INTO arch FROM archetypes WHERE id = prod.archetype_id;
    END IF;

    d := COALESCE(prod.shelf_life_after_opening_days, arch.open_shelf_life_days);
    u := COALESCE(prod.shelf_life_after_opening_unit, arch.open_shelf_life_unit, 'days');

    IF d IS NOT NULL THEN
      NEW.expiration_after_opening :=
        CASE u
          WHEN 'hours' THEN (NEW.opened_on + (d || ' hours')::INTERVAL)::DATE
          ELSE            (NEW.opened_on + (d || ' days')::INTERVAL)::DATE
        END;
    END IF;
  END IF;

  RETURN NEW;
END; $function$
"
FUNCTION,set_updated_at,"CREATE OR REPLACE FUNCTION public.set_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END; $function$
"
FUNCTION,show_limit,"CREATE OR REPLACE FUNCTION public.show_limit()
 RETURNS real
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$show_limit$function$
"
FUNCTION,show_trgm,"CREATE OR REPLACE FUNCTION public.show_trgm(text)
 RETURNS text[]
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$show_trgm$function$
"
FUNCTION,similarity,"CREATE OR REPLACE FUNCTION public.similarity(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$similarity$function$
"
FUNCTION,similarity_dist,"CREATE OR REPLACE FUNCTION public.similarity_dist(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$similarity_dist$function$
"
FUNCTION,similarity_op,"CREATE OR REPLACE FUNCTION public.similarity_op(text, text)
 RETURNS boolean
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$similarity_op$function$
"
FUNCTION,strict_word_similarity,"CREATE OR REPLACE FUNCTION public.strict_word_similarity(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$strict_word_similarity$function$
"
FUNCTION,strict_word_similarity_commutator_op,"CREATE OR REPLACE FUNCTION public.strict_word_similarity_commutator_op(text, text)
 RETURNS boolean
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$strict_word_similarity_commutator_op$function$
"
FUNCTION,strict_word_similarity_dist_commutator_op,"CREATE OR REPLACE FUNCTION public.strict_word_similarity_dist_commutator_op(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$strict_word_similarity_dist_commutator_op$function$
"
FUNCTION,strict_word_similarity_dist_op,"CREATE OR REPLACE FUNCTION public.strict_word_similarity_dist_op(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$strict_word_similarity_dist_op$function$
"
FUNCTION,strict_word_similarity_op,"CREATE OR REPLACE FUNCTION public.strict_word_similarity_op(text, text)
 RETURNS boolean
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$strict_word_similarity_op$function$
"
FUNCTION,tg_set_timestamp,"CREATE OR REPLACE FUNCTION public.tg_set_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  new.updated_at = now();
  return new;
end $function$
"
FUNCTION,trigger_auto_expiration_date,"CREATE OR REPLACE FUNCTION public.trigger_auto_expiration_date()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    -- Si pas de date d'expiration fournie, la calculer automatiquement
    IF NEW.expiration_date IS NULL AND NEW.storage_method IS NOT NULL THEN
        DECLARE
            v_product_id UUID;
            v_shelf_life_days INTEGER;
        BEGIN
            -- Déterminer l'ID du produit
            v_product_id := COALESCE(
                NEW.canonical_food_id,
                NEW.cultivar_id,
                NEW.generic_product_id,
                NEW.derived_product_id
            );
            
            IF v_product_id IS NOT NULL THEN
                -- Récupérer la durée de conservation appropriée
                SELECT CASE NEW.storage_method
                    WHEN 'fridge' THEN shelf_life_days_fridge
                    WHEN 'freezer' THEN shelf_life_days_freezer
                    WHEN 'pantry' THEN shelf_life_days_pantry
                    WHEN 'counter' THEN LEAST(shelf_life_days_fridge, shelf_life_days_pantry)
                    ELSE shelf_life_days_fridge
                END INTO v_shelf_life_days
                FROM v_inventory_display 
                WHERE canonical_food_id = v_product_id 
                   OR cultivar_id = v_product_id 
                   OR generic_product_id = v_product_id 
                   OR derived_product_id = v_product_id
                LIMIT 1;
                
                -- Valeur par défaut si pas trouvée
                IF v_shelf_life_days IS NULL THEN
                    v_shelf_life_days := CASE NEW.storage_method
                        WHEN 'fridge' THEN 7
                        WHEN 'freezer' THEN 365
                        WHEN 'pantry' THEN 30
                        WHEN 'counter' THEN 3
                        ELSE 7
                    END;
                END IF;
                
                NEW.expiration_date := COALESCE(NEW.acquired_on, CURRENT_DATE) + v_shelf_life_days;
            END IF;
        END;
    END IF;
    
    -- S'assurer que initial_qty est définie
    IF NEW.initial_qty IS NULL THEN
        NEW.initial_qty := NEW.qty_remaining;
    END IF;
    
    RETURN NEW;
END;
$function$
"
FUNCTION,unaccent,"CREATE OR REPLACE FUNCTION public.unaccent(text)
 RETURNS text
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/unaccent', $function$unaccent_dict$function$
"
FUNCTION,unaccent,"CREATE OR REPLACE FUNCTION public.unaccent(regdictionary, text)
 RETURNS text
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/unaccent', $function$unaccent_dict$function$
"
FUNCTION,unaccent,"CREATE OR REPLACE FUNCTION public.unaccent(regdictionary, text)
 RETURNS text
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/unaccent', $function$unaccent_dict$function$
"
FUNCTION,unaccent,"CREATE OR REPLACE FUNCTION public.unaccent(text)
 RETURNS text
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/unaccent', $function$unaccent_dict$function$
"
FUNCTION,unaccent_init,"CREATE OR REPLACE FUNCTION public.unaccent_init(internal)
 RETURNS internal
 LANGUAGE c
 PARALLEL SAFE
AS '$libdir/unaccent', $function$unaccent_init$function$
"
FUNCTION,unaccent_lexize,"CREATE OR REPLACE FUNCTION public.unaccent_lexize(internal, internal, internal, internal)
 RETURNS internal
 LANGUAGE c
 PARALLEL SAFE
AS '$libdir/unaccent', $function$unaccent_lexize$function$
"
FUNCTION,unit_is_valid,"CREATE OR REPLACE FUNCTION public.unit_is_valid(u text)
 RETURNS boolean
 LANGUAGE sql
 IMMUTABLE
AS $function$
  select coalesce(u ~ '^(g|kg|ml|cl|l|u|tranche|feuille|gousse|filets?|sachet|botte|p|càs|càc|louche|verre|bol|pinch|cup|tbsp|tsp|mls?)$', true)
$function$
"
FUNCTION,update_updated_at_column,"CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$function$
"
FUNCTION,upsert_unit_conv_generic,"CREATE OR REPLACE FUNCTION public.upsert_unit_conv_generic(p_from text, p_to text, p_factor numeric)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
declare
  f text := public.norm_text(p_from);
  t text := public.norm_text(p_to);
  x numeric := p_factor;
begin
  if f is null or f='' or t is null or t='' or x is null or x=0 then
    raise exception 'Paramètres invalides';
  end if;

  -- direct
  insert into public.unit_conversions_generic(from_unit, to_unit, factor)
  values (f, t, x)
  on conflict on constraint idx_unit_conv_generic_norm
  do update set factor = excluded.factor;

  -- inverse
  insert into public.unit_conversions_generic(from_unit, to_unit, factor)
  values (t, f, 1/x)
  on conflict on constraint idx_unit_conv_generic_norm
  do update set factor = excluded.factor;
end
$function$
"
FUNCTION,upsert_unit_conv_product,"CREATE OR REPLACE FUNCTION public.upsert_unit_conv_product(p_product_id uuid, p_from text, p_to text, p_factor numeric)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
declare
  f text := public.norm_text(p_from);
  t text := public.norm_text(p_to);
  x numeric := p_factor;
begin
  if p_product_id is null or f is null or f='' or t is null or t='' or x is null or x=0 then
    raise exception 'Paramètres invalides';
  end if;

  -- direct
  insert into public.unit_conversions_product(product_id, from_unit, to_unit, factor)
  values (p_product_id, f, t, x)
  on conflict on constraint idx_unit_conv_product_norm
  do update set factor = excluded.factor;

  -- inverse
  insert into public.unit_conversions_product(product_id, from_unit, to_unit, factor)
  values (p_product_id, t, f, 1/x)
  on conflict on constraint idx_unit_conv_product_norm
  do update set factor = excluded.factor;
end
$function$
"
FUNCTION,word_similarity,"CREATE OR REPLACE FUNCTION public.word_similarity(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$word_similarity$function$
"
FUNCTION,word_similarity_commutator_op,"CREATE OR REPLACE FUNCTION public.word_similarity_commutator_op(text, text)
 RETURNS boolean
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$word_similarity_commutator_op$function$
"
FUNCTION,word_similarity_dist_commutator_op,"CREATE OR REPLACE FUNCTION public.word_similarity_dist_commutator_op(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$word_similarity_dist_commutator_op$function$
"
FUNCTION,word_similarity_dist_op,"CREATE OR REPLACE FUNCTION public.word_similarity_dist_op(text, text)
 RETURNS real
 LANGUAGE c
 IMMUTABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$word_similarity_dist_op$function$
"
FUNCTION,word_similarity_op,"CREATE OR REPLACE FUNCTION public.word_similarity_op(text, text)
 RETURNS boolean
 LANGUAGE c
 STABLE PARALLEL SAFE STRICT
AS '$libdir/pg_trgm', $function$word_similarity_op$function$
"
TABLE,archetypes,CREATE TABLE archetypes AS SELECT * FROM archetypes LIMIT 0
TABLE,canonical_foods,CREATE TABLE canonical_foods AS SELECT * FROM canonical_foods LIMIT 0
TABLE,cultivars,CREATE TABLE cultivars AS SELECT * FROM cultivars LIMIT 0
TABLE,inventory_lots,CREATE TABLE inventory_lots AS SELECT * FROM inventory_lots LIMIT 0
TABLE,locations,CREATE TABLE locations AS SELECT * FROM locations LIMIT 0
TABLE,products,CREATE TABLE products AS SELECT * FROM products LIMIT 0
TABLE,recipe_ingredients,CREATE TABLE recipe_ingredients AS SELECT * FROM recipe_ingredients LIMIT 0
TABLE,recipe_steps,CREATE TABLE recipe_steps AS SELECT * FROM recipe_steps LIMIT 0
TABLE,recipe_tools,CREATE TABLE recipe_tools AS SELECT * FROM recipe_tools LIMIT 0
TABLE,recipe_utensils,CREATE TABLE recipe_utensils AS SELECT * FROM recipe_utensils LIMIT 0
TABLE,recipes,CREATE TABLE recipes AS SELECT * FROM recipes LIMIT 0
TABLE,reference_categories,CREATE TABLE reference_categories AS SELECT * FROM reference_categories LIMIT 0
TABLE,reference_subcategories,CREATE TABLE reference_subcategories AS SELECT * FROM reference_subcategories LIMIT 0
TABLE,storage_guides,CREATE TABLE storage_guides AS SELECT * FROM storage_guides LIMIT 0
TABLE,substitutions,CREATE TABLE substitutions AS SELECT * FROM substitutions LIMIT 0
TABLE,unit_conversions_generic,CREATE TABLE unit_conversions_generic AS SELECT * FROM unit_conversions_generic LIMIT 0
TABLE,unit_conversions_product,CREATE TABLE unit_conversions_product AS SELECT * FROM unit_conversions_product LIMIT 0
TABLE,utensils_catalog,CREATE TABLE utensils_catalog AS SELECT * FROM utensils_catalog LIMIT 0
TRIGGER,t_ua_inventory_lots,CREATE TRIGGER t_ua_inventory_lots BEFORE UPDATE ON public.inventory_lots FOR EACH ROW EXECUTE FUNCTION set_updated_at()
TRIGGER,t_ua_products,CREATE TRIGGER t_ua_products BEFORE UPDATE ON public.products FOR EACH ROW EXECUTE FUNCTION set_updated_at()
TRIGGER,trg_check_canonical_subcategory,CREATE TRIGGER trg_check_canonical_subcategory BEFORE INSERT OR UPDATE ON public.canonical_foods FOR EACH ROW EXECUTE FUNCTION check_canonical_subcategory_match()
TRIGGER,trg_check_canonical_subcategory,CREATE TRIGGER trg_check_canonical_subcategory BEFORE INSERT OR UPDATE ON public.canonical_foods FOR EACH ROW EXECUTE FUNCTION check_canonical_subcategory_match()
TRIGGER,trg_set_open_expiration,CREATE TRIGGER trg_set_open_expiration BEFORE INSERT OR UPDATE ON public.inventory_lots FOR EACH ROW EXECUTE FUNCTION set_open_expiration()
TRIGGER,trg_set_open_expiration,CREATE TRIGGER trg_set_open_expiration BEFORE INSERT OR UPDATE ON public.inventory_lots FOR EACH ROW EXECUTE FUNCTION set_open_expiration()
TRIGGER,trg_updated_at_archetypes,CREATE TRIGGER trg_updated_at_archetypes BEFORE UPDATE ON public.archetypes FOR EACH ROW EXECUTE FUNCTION set_updated_at()
TRIGGER,trg_updated_at_canonical_foods,CREATE TRIGGER trg_updated_at_canonical_foods BEFORE UPDATE ON public.canonical_foods FOR EACH ROW EXECUTE FUNCTION set_updated_at()
TRIGGER,trg_updated_at_cultivars,CREATE TRIGGER trg_updated_at_cultivars BEFORE UPDATE ON public.cultivars FOR EACH ROW EXECUTE FUNCTION set_updated_at()