### CONTEXTE ###
Tu es un expert en ingénierie de données culinaires. Ta mission est de peupler une base de données PostgreSQL à partir d'une liste de noms de recettes.

La structure de la base de données est la suivante :
- `recipes`: Contient les informations générales de la recette (nom, description, temps, portions, rôle ['PLAT_PRINCIPAL', 'ACCOMPAGNEMENT', 'ENTREE', 'DESSERT']).
- `canonical_foods`: Contient les ingrédients bruts, génériques non interchangeable (ex: 'pomme de terre à chair ferme', 'blé').
- `archetypes`: Contient les formes spécifiques ou transformées d'un ingrédient (ex: 'compote de pomme', 'yaourt','farine de blé). Chaque archétype est lié à un `canonical_food_id`.
- `recipe_ingredients`: Table de liaison qui connecte une recette à un `canonical_food_id` OU à un `archetype_id`.
- `tags`: Contient les tags de classification (ex: 'cuisine:Française', 'profil:Réconfortant', 'usage:Facile').
- `recipe_tags`: Table de liaison entre les recettes et les tags.
- `processes`: Contient les méthodes de cuisson (ex: 'Rôtissage', 'Mijotage').
- `recipe_steps`: Contient les étapes de la recette, chaque étape pouvant être liée à un `process_id`.

### MISSION ###
Générer un script PostgreSQL **unique, complet et directement exécutable** qui peuple toutes ces tables pour une liste de recettes fournie. Le script doit être intelligent : il doit créer les ingrédients (`canonical_foods`, `archetypes`) et les `tags` qui n'existent pas encore.

### RÈGLES DE GÉNÉRATION (TRÈS IMPORTANTES) ###

1.  **TRANSACTION UNIQUE** : L'ensemble du script DOIT être encapsulé dans une transaction (`BEGIN;` ... `COMMIT;`).
2.  **ANALYSE DE RECETTE** : Pour chaque nom de recette, tu dois utiliser tes connaissances pour déduire :
    - Une description courte et pertinente.
    - Les temps de préparation et de cuisson approximatifs.
    - Un nombre de portions standard (généralement 4 ou 6).
    - Son rôle principal (PLAT_PRINCIPAL, DESSERT, etc.).
    - Une liste d'ingrédients détaillés, en distinguant si l'ingrédient est générique (`canonical_food`) ou spécifique (`archetype`).
    - Les étapes de préparation claires.
    - Une liste de tags pertinents (`cuisine:`, `profil:`, `usage:`, `régime:`).

3.  **CRÉATION "INTELLIGENTE" DES DÉPENDANCES (UPSERT)** : Pour éviter les doublons et les erreurs, tu DOIS utiliser des CTEs (Common Table Expressions) avec `INSERT ... ON CONFLICT DO NOTHING` pour chaque dépendance AVANT d'insérer la recette elle-même.

    - **Pour les `canonical_foods`** : Pour chaque ingrédient brut requis par les recettes, utilise ce modèle pour l'insérer s'il n'existe pas, et récupérer son ID dans tous les cas :
      ```sql
      WITH ins_can AS (
          INSERT INTO canonical_foods (canonical_name, category_id)
          VALUES ('nom_ingredient_en_minuscule', id_categorie_approximatif)
          ON CONFLICT (canonical_name) DO NOTHING
          RETURNING id
      )
      SELECT id FROM ins_can
      UNION ALL
      SELECT id FROM canonical_foods WHERE canonical_name = 'nom_ingredient_en_minuscule'
      LIMIT 1;
      ```

    - **Pour les `archetypes`** : Fais de même pour les ingrédients spécifiques, en liant l'archétype à son `canonical_food_id` récupéré juste avant.

    - **Pour les `tags`** : Utilise la même logique pour insérer les tags nécessaires s'ils n'existent pas.

4.  **INSERTION FINALE** : Une fois tous les ID des dépendances récupérés dans des variables ou via des CTEs, insère la recette dans `recipes`, puis peuple les tables de liaison `recipe_ingredients` et `recipe_tags`, et enfin la table `recipe_steps`.

5.  **TRAITEMENT PAR LOT** : Répète ce processus complet pour CHAQUE recette de la liste fournie, au sein de la même transaction.

### FORMAT DE SORTIE ###

1.  **BLOC SQL UNIQUE** : Le résultat doit être un unique bloc de code SQL, commençant par `BEGIN;` et finissant par `COMMIT;`. Ne fournis AUCUN texte explicatif avant ou après le bloc de code.
2.  **RAPPORT DE VÉRIFICATION** : À la toute fin du script, après le `COMMIT;`, ajoute un bloc de commentaires SQL formaté pour que je puisse vérifier les ajouts. Ce bloc ne doit contenir que les noms des `canonical_foods` et `archetypes` qui ont été **effectivement créés** pendant l'exécution du script (ceux pour qui la clause `ON CONFLICT` n'a pas été déclenchée).

    **Format du rapport :**
    ```sql
    -- ===================================================================
    -- RAPPORT DE VÉRIFICATION DES AJOUTS
    -- ===================================================================
    --
    -- NOUVEAUX CANONICAL FOODS AJOUTÉS :
    -- - nom_ingredient_1
    -- - nom_ingredient_2
    --
    -- NOUVEAUX ARCHETYPES AJOUTÉS :
    -- - nom_archetype_1
    -- - nom_archetype_2
    --
    -- RECETTES TRAITÉES AVEC SUCCÈS :
    -- - Nom de la recette 1
    -- - Nom de la recette 2
    --
    -- ===================================================================
    ```

Maintenant, applique cette logique pour les recettes suivantes :