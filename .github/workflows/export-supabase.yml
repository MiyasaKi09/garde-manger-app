name: Export Supabase (safe write to main → supabase/exports/latest)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      DB_NAME: postgres
      PGSSLMODE: require

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y postgresql-client dnsutils zip

      # Normalize secrets
      - name: Normalize secrets
        id: norm
        shell: bash
        env:
          RAW_HOST: "${{ secrets.SUPABASE_POOLER_HOST }}"
          RAW_REF:  "${{ secrets.SUPABASE_PROJECT_REF }}"
        run: |
          set -e
          H="$RAW_HOST"
          H="${H#postgresql://}"; H="${H#postgres://}"
          [[ "$H" == *"@"* ]] && H="${H#*@}"
          H="${H%%/*}"
          H="${H%%:*}"
          H="$(echo -n "$H" | tr -d '[:space:]')"
          if [ -z "$H" ]; then
            echo "Host empty after normalization; check SUPABASE_POOLER_HOST secret"
            exit 1
          fi
          REF_CLEAN="$(echo -n "$RAW_REF" | tr -d '[:space:]')"
          if [ -z "$REF_CLEAN" ]; then
            echo "Project ref empty; check SUPABASE_PROJECT_REF secret"
            exit 1
          fi
          echo "HOST_CLEAN=$H" >> "$GITHUB_ENV"
          echo "REF_CLEAN=$REF_CLEAN" >> "$GITHUB_ENV"
          echo "Normalized host: $H"
          echo "Normalized ref: $REF_CLEAN"

      - name: DNS check
        shell: bash
        run: |
          set -e
          echo "Checking DNS for $HOST_CLEAN ..."
          nslookup "$HOST_CLEAN" >/dev/null 2>&1 || { echo "DNS resolution failed for $HOST_CLEAN"; exit 1; }
          echo "DNS ok"

      # Detect connection (6543/6544 × modes)
      - name: Detect working connection (6543/6544 × modes)
        id: pick
        shell: bash
        env:
          PGPASSWORD: "${{ secrets.SUPABASE_DB_PASSWORD }}"
        run: |
          set +e
          HOST="$HOST_CLEAN"
          REF="$REF_CLEAN"
          DB="$DB_NAME"

          try_conn() {
            local PORT="$1" USER="$2" PGOPT="$3" MODE_NAME="$4"
            echo "Trying $MODE_NAME: host=$HOST port=$PORT user=$USER pgopt='$PGOPT'"
            if [ -n "$PGOPT" ]; then
              PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select 'OK', current_user;" 2>&1
            else
              psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select 'OK', current_user;" 2>&1
            fi
            return $?
          }

          if try_conn 6543 "postgres.${REF}" "" "A_6543_user_ref"; then
            echo "PORT=6543" >> "$GITHUB_OUTPUT"
            echo "USER=postgres.${REF}" >> "$GITHUB_OUTPUT"
            echo "PGOPT=" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if try_conn 6543 "postgres" "project=${REF}" "B_6543_pgopt"; then
            echo "PORT=6543" >> "$GITHUB_OUTPUT"
            echo "USER=postgres" >> "$GITHUB_OUTPUT"
            echo "PGOPT=project=${REF}" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if try_conn 6544 "postgres.${REF}" "" "C_6544_user_ref"; then
            echo "PORT=6544" >> "$GITHUB_OUTPUT"
            echo "USER=postgres.${REF}" >> "$GITHUB_OUTPUT"
            echo "PGOPT=" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if try_conn 6544 "postgres" "project=${REF}" "D_6544_pgopt"; then
            echo "PORT=6544" >> "$GITHUB_OUTPUT"
            echo "USER=postgres" >> "$GITHUB_OUTPUT"
            echo "PGOPT=project=${REF}" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "No working connection found (tested 6543/6544 × modes). Check secrets and network."
          exit 1

      # Set variables for export directory
      - name: Prepare export paths
        run: |
          set -e
          export EXPORT_BASE="supabase/exports"
          export EXPORT_LATEST="$EXPORT_BASE/latest"
          mkdir -p "$EXPORT_LATEST" supabase/csv
          echo "EXPORT_BASE=$EXPORT_BASE" >> "$GITHUB_ENV"
          echo "EXPORT_LATEST=$EXPORT_LATEST" >> "$GITHUB_ENV"
          echo "Created $EXPORT_LATEST"

      # Generate schema.md into export folder
      - name: Generate schema.md into export folder
        if: steps.pick.outputs.ok == '1'
        shell: bash
        env:
          PGPASSWORD: "${{ secrets.SUPABASE_DB_PASSWORD }}"
          HOST: "${{ env.HOST_CLEAN }}"
          PORT: "${{ steps.pick.outputs.PORT }}"
          USER: "${{ steps.pick.outputs.USER }}"
          PGOPT: "${{ steps.pick.outputs.PGOPT }}"
          DB: "${{ env.DB_NAME }}"
        run: |
          set -e
          mkdir -p "$EXPORT_LATEST"
          if [ -n "$PGOPT" ]; then
            PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -v ON_ERROR_STOP=1 -f tools/schema_report.sql > "$EXPORT_LATEST/schema.md"
          else
            psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -v ON_ERROR_STOP=1 -f tools/schema_report.sql > "$EXPORT_LATEST/schema.md"
          fi
          echo "Generated $EXPORT_LATEST/schema.md"

      # Export tables to CSV into a temp dir, then move to export latest
      - name: Export public tables to CSV and move to export folder
        if: steps.pick.outputs.ok == '1'
        shell: bash
        env:
          PGPASSWORD: "${{ secrets.SUPABASE_DB_PASSWORD }}"
          HOST: "${{ env.HOST_CLEAN }}"
          PORT: "${{ steps.pick.outputs.PORT }}"
          USER: "${{ steps.pick.outputs.USER }}"
          PGOPT: "${{ steps.pick.outputs.PGOPT }}"
          DB: "${{ env.DB_NAME }}"
        run: |
          set -e
          TMP="data_export"
          rm -rf "$TMP"
          mkdir -p "$TMP" "$EXPORT_LATEST/csv"
          echo "# Data export summary" > "$EXPORT_LATEST/data_summary.md"
          echo "_Generated: $(date -u)_" >> "$EXPORT_LATEST/data_summary.md"
          echo >> "$EXPORT_LATEST/data_summary.md"
          echo "## Tables and counts" >> "$EXPORT_LATEST/data_summary.md"

          if [ -n "$PGOPT" ]; then
            LIST=$(PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select tablename from pg_tables where schemaname='public' order by tablename;")
            for T in $LIST; do
              echo "Exporting $T..."
              PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -c "\copy public.\"$T\" to '${TMP}/${T}.csv' csv header"
              CNT=$(PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select count(*) from public.\"$T\";")
              echo "- $T: $CNT rows" >> "$EXPORT_LATEST/data_summary.md"
            done
          else
            LIST=$(psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select tablename from pg_tables where schemaname='public' order by tablename;")
            for T in $LIST; do
              echo "Exporting $T..."
              psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -c "\copy public.\"$T\" to '${TMP}/${T}.csv' csv header"
              CNT=$(psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select count(*) from public.\"$T\";")
              echo "- $T: $CNT rows" >> "$EXPORT_LATEST/data_summary.md"
            done
          fi

          # Move csv to the export folder (overwrite only files under export latest)
          mkdir -p "$EXPORT_LATEST/csv"
          mv "$TMP"/*.csv "$EXPORT_LATEST/csv/" || true
          rm -rf "$TMP"
          ( cd "$EXPORT_LATEST" && zip -9 -r ../../data-csv.zip csv schema.md data_summary.md ) || true
          echo "CSV export done, files in $EXPORT_LATEST/csv/"

      - name: Upload CSV zip
        if: steps.pick.outputs.ok == '1'
        uses: actions/upload-artifact@v4
        with:
          name: supabase-data-csv
          path: data-csv.zip

      # Commit only the export folder to main (no force) — handle deletions inside that folder
      - name: Commit export folder to main (safe, only export folder)
        if: steps.pick.outputs.ok == '1'
        shell: bash
        run: |
          set -e
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Update local main to latest remote
          git fetch origin main
          git checkout main
          git reset --soft origin/main

          # Remove tracked files under supabase/exports/latest (so deletions are recorded),
          # but DO NOT touch any other paths.
          git rm -r --ignore-unmatch supabase/exports/latest || true

          # Add the new export folder (adds new files and staged deletions)
          git add -A supabase/exports/latest

          if git diff --cached --quiet; then
            echo "No changes to commit in supabase/exports/latest."
            exit 0
          fi

          git commit -m "chore(export): update supabase/exports/latest"
          git push origin main

