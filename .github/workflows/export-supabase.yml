name: Export Supabase (schema + CSV + summary → /supabase, auto-detect)

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  run:
    runs-on: ubuntu-latest
    env:
      DB_NAME: postgres
      PGSSLMODE: require

    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies
        run: sudo apt-get update && sudo apt-get install -y postgresql-client dnsutils zip

      # 1) Normalize secrets into HOST_CLEAN and REF_CLEAN
      - name: Normalize secrets
        id: norm
        shell: bash
        env:
          RAW_HOST: "${{ secrets.SUPABASE_POOLER_HOST }}"
          RAW_REF:  "${{ secrets.SUPABASE_PROJECT_REF }}"
        run: |
          set -e
          H="$RAW_HOST"
          H="${H#postgresql://}"; H="${H#postgres://}"
          [[ "$H" == *"@"* ]] && H="${H#*@}"
          H="${H%%/*}"
          H="${H%%:*}"
          H="$(echo -n "$H" | tr -d '[:space:]')"
          if [ -z "$H" ]; then
            echo "Host empty after normalization; check SUPABASE_POOLER_HOST secret"
            exit 1
          fi
          REF_CLEAN="$(echo -n "$RAW_REF" | tr -d '[:space:]')"
          if [ -z "$REF_CLEAN" ]; then
            echo "Project ref empty; check SUPABASE_PROJECT_REF secret"
            exit 1
          fi
          echo "HOST_CLEAN=$H" >> "$GITHUB_ENV"
          echo "REF_CLEAN=$REF_CLEAN" >> "$GITHUB_ENV"
          echo "Normalized host: $H"
          echo "Normalized ref: $REF_CLEAN"

      - name: DNS check
        shell: bash
        run: |
          set -e
          echo "Checking DNS for $HOST_CLEAN ..."
          nslookup "$HOST_CLEAN" >/dev/null 2>&1 || { echo "DNS resolution failed for $HOST_CLEAN"; exit 1; }
          echo "DNS ok"

      # 2) Detect working connection: try ports 6543 then 6544; for each try postgres.<ref> then postgres + PGOPTIONS
      - name: Detect working connection (6543/6544 × modes)
        id: pick
        shell: bash
        env:
          PGPASSWORD: "${{ secrets.SUPABASE_DB_PASSWORD }}"
        run: |
          set +e
          HOST="$HOST_CLEAN"
          REF="$REF_CLEAN"
          DB="$DB_NAME"

          try_conn() {
            local PORT="$1" USER="$2" PGOPT="$3" MODE_NAME="$4"
            echo "Trying $MODE_NAME: host=$HOST port=$PORT user=$USER pgopt='$PGOPT'"
            if [ -n "$PGOPT" ]; then
              PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select 'OK' as ok, current_user;" 2>&1
            else
              psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select 'OK' as ok, current_user;" 2>&1
            fi
            return $?
          }

          # try combinations
          if try_conn 6543 "postgres.${REF}" "" "A_6543_user_ref"; then
            echo "PORT=6543" >> "$GITHUB_OUTPUT"
            echo "USER=postgres.${REF}" >> "$GITHUB_OUTPUT"
            echo "PGOPT=" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if try_conn 6543 "postgres" "project=${REF}" "B_6543_pgopt"; then
            echo "PORT=6543" >> "$GITHUB_OUTPUT"
            echo "USER=postgres" >> "$GITHUB_OUTPUT"
            echo "PGOPT=project=${REF}" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if try_conn 6544 "postgres.${REF}" "" "C_6544_user_ref"; then
            echo "PORT=6544" >> "$GITHUB_OUTPUT"
            echo "USER=postgres.${REF}" >> "$GITHUB_OUTPUT"
            echo "PGOPT=" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if try_conn 6544 "postgres" "project=${REF}" "D_6544_pgopt"; then
            echo "PORT=6544" >> "$GITHUB_OUTPUT"
            echo "USER=postgres" >> "$GITHUB_OUTPUT"
            echo "PGOPT=project=${REF}" >> "$GITHUB_OUTPUT"
            echo "ok=1" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "No working connection found (tested 6543/6544 × modes). Check secrets and network."
          exit 1

      # 3) Create supabase dir and generate schema.md there
      - name: Generate schema.md into supabase/
        if: steps.pick.outputs.ok == '1'
        shell: bash
        env:
          PGPASSWORD: "${{ secrets.SUPABASE_DB_PASSWORD }}"
          HOST: "${{ env.HOST_CLEAN }}"
          PORT: "${{ steps.pick.outputs.PORT }}"
          USER: "${{ steps.pick.outputs.USER }}"
          PGOPT: "${{ steps.pick.outputs.PGOPT }}"
          DB: "${{ env.DB_NAME }}"
        run: |
          set -e
          mkdir -p supabase
          if [ -n "$PGOPT" ]; then
            PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -v ON_ERROR_STOP=1 -f tools/schema_report.sql > supabase/schema.md
          else
            psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -v ON_ERROR_STOP=1 -f tools/schema_report.sql > supabase/schema.md
          fi
          echo "Generated supabase/schema.md"

      - name: Upload schema artifact
        if: steps.pick.outputs.ok == '1'
        uses: actions/upload-artifact@v4
        with:
          name: schema-report
          path: supabase/schema.md

      # 4) Export tables to CSV then move into supabase/csv/
      - name: Export public tables to CSV and move to supabase/csv
        if: steps.pick.outputs.ok == '1'
        shell: bash
        env:
          PGPASSWORD: "${{ secrets.SUPABASE_DB_PASSWORD }}"
          HOST: "${{ env.HOST_CLEAN }}"
          PORT: "${{ steps.pick.outputs.PORT }}"
          USER: "${{ steps.pick.outputs.USER }}"
          PGOPT: "${{ steps.pick.outputs.PGOPT }}"
          DB: "${{ env.DB_NAME }}"
        run: |
          set -e
          rm -rf data_export supabase/csv
          mkdir -p data_export supabase/csv

          if [ -n "$PGOPT" ]; then
            LIST=$(PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select tablename from pg_tables where schemaname='public' order by tablename;")
            for T in $LIST; do
              echo "Exporting $T..."
              PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -c "\copy public.\"$T\" to 'data_export/${T}.csv' csv header"
            done
          else
            LIST=$(psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc "select tablename from pg_tables where schemaname='public' order by tablename;")
            for T in $LIST; do
              echo "Exporting $T..."
              psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -c "\copy public.\"$T\" to 'data_export/${T}.csv' csv header"
            done
          fi

          # move into supabase/csv
          mv data_export/*.csv supabase/csv/ || true
          ( cd supabase && zip -9 -r ../data-csv.zip csv ) || true
          echo "CSV export done, files in supabase/csv/"

      - name: Upload CSV zip
        if: steps.pick.outputs.ok == '1'
        uses: actions/upload-artifact@v4
        with:
          name: supabase-data-csv
          path: data-csv.zip

      # 5) Generate data_summary.md in supabase/
      - name: Generate data_summary.md in supabase/
        if: steps.pick.outputs.ok == '1'
        shell: bash
        env:
          PGPASSWORD: "${{ secrets.SUPABASE_DB_PASSWORD }}"
          HOST: "${{ env.HOST_CLEAN }}"
          PORT: "${{ steps.pick.outputs.PORT }}"
          USER: "${{ steps.pick.outputs.USER }}"
          PGOPT: "${{ steps.pick.outputs.PGOPT }}"
          DB: "${{ env.DB_NAME }}"
        run: |
          set -e
          mkdir -p supabase
          echo "# Data export summary" > supabase/data_summary.md
          if [ -n "$PGOPT" ]; then
            PGOPTIONS="$PGOPT" psql "host=$HOST port=$PORT dbname=$DB user=$USER sslmode=require" -Atc \
              "select tablename, count(*) from pg_tables t left join lateral (select count(*) from public.\"\" || t.tablename || \"\" ) c on true" \
              >> supabase/data_summary.md 2>/dev/null || true
          fi
          # fallback: list files and sizes
          echo "" >> supabase/data_summary.md
          echo "### CSV files" >> supabase/data_summary.md
          ls -lh supabase/csv/ >> supabase/data_summary.md || true
          echo "Generated supabase/data_summary.md"

      # 6) Commit & force-push (overwrite) supabase/ and data-csv.zip
          - name: Commit and overwrite remote (properly handle deletions)
        if: steps.pick.outputs.ok == '1'
        shell: bash
        run: |
          set -e
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

          # Récupère la dernière version distante
          git fetch origin main
          git checkout main
          git reset --hard origin/main

          # Supprime l'ancien dossier suivi (s'il existe) pour forcer la suppression dans l'historique
          git rm -r --ignore-unmatch supabase || true

          # Ajoute tout (ajouts, modifications ET suppressions)
          git add -A

          # Si rien à committer, on stoppe proprement
          if git diff --cached --quiet; then
            echo "No changes to commit."
            exit 0
          fi

          # Commit & push (force pour écraser si nécessaire)
          git commit -m "chore(export): overwrite supabase schema, csv and summary"
          git push origin main --force
